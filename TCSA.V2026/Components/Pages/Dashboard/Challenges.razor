@page "/dashboard/challenges"
@using Microsoft.AspNetCore.Authorization
@using System.Security.Claims
@using TCSA.V2026.Data.DTOs
@using TCSA.V2026.Data.Models
@using TCSA.V2026.Data.Models.Responses
@using TCSA.V2026.Helpers
@using TCSA.V2026.Helpers.Constants
@using TCSA.V2026.Services
@using TCSA.V2026.Services.Challenges
@attribute [Authorize]
@implements IDisposable

<MudContainer>
    @if (User != null)
    {
        <DashboardToolBar User=@User></DashboardToolBar>
    }
    <h1 class="visually-hidden">Challenges</h1>
    <MudStack Row Class="mt-4" Spacing="4" Breakpoint="Breakpoint.Xs">
        <MudPaper Class="flex-grow-1 pb-3" Elevation="3" Outlined="false">
            <MudStack AlignItems="AlignItems.Center" Spacing="2" Class="py-3 px-4 px-md-5" Style="@($"background-color:{Colors.Green.Lighten1}")">
                <i class="fas fa-check-circle fa-3x" style="color: white;" />
                <MudText Typo="Typo.subtitle1" Style="font-weight: bold; color: white;">COMPLETED</MudText>
            </MudStack>
            <MudStack Spacing="0" AlignItems="AlignItems.Center" Class="px-4 px-md-5">
                <MudText Style="font-size: 2.5rem; font-weight: bolder;">@CompletedChallenges.Count</MudText>
                <MudText Style="font-size: 1.25rem;">Challenges</MudText>
            </MudStack>
        </MudPaper>
        <MudPaper Class="flex-grow-1 pb-3" Elevation="3" Outlined="false">
            <MudStack AlignItems="AlignItems.Center" Spacing="2" Class="py-3 px-4 px-md-5" Style="@($"background-color:{Colors.Red.Default}")">
                <i class="fas fa-fire fa-3x" style="color: white;" />
                <MudText Typo="Typo.subtitle1" Style="font-weight: bold; color: white;">STREAK</MudText>
            </MudStack>
            <MudStack Spacing="0" AlignItems="AlignItems.Center" Class="px-4 px-md-5">
                <MudText Style="font-size: 2.5rem; font-weight: bolder;">@UserStreak.CurrentStreak</MudText>
                <MudText Style="font-size: 1.25rem;">Days</MudText>
                <MudText Typo="Typo.caption">Best: @UserStreak.LongestStreak days</MudText>
            </MudStack>
        </MudPaper>
    </MudStack>

    @if (IsLoading)
    {
        <MudProgressCircular Color="Color.Default" Indeterminate="true" />
    }
    else
    {
        @*  <MudText>LoadTime: @LoadTime.TotalSeconds.ToString()</MudText> *@
        if (ChallengesList != null && ChallengesList.Count > 0)
        {
            <MudStack Row Class="mt-6 mb-4" Spacing="4" AlignItems="AlignItems.Center" Breakpoint="Breakpoint.Xs">                
                <MudCheckBox @bind-Value="@ShowCompleted"
                Label="Show Completed"
                CheckedIcon="@Icons.Material.Outlined.CheckBox"
                UncheckedIcon="@Icons.Material.Outlined.CheckBoxOutlineBlank" />
                <MudStack Row Spacing="4">
                    <MudSelect T="Level"
                    Label="Filter by Level"
                    Placeholder="Level"
                    Class="flex-grow-0"
                    MultiSelection="true"                
                    @bind-SelectedValues="SelectedLevels">
                        @foreach (Level item in Enum.GetValues(typeof(Level)))
                        {
                            <MudSelectItem Value="@item">@item.ToString()</MudSelectItem>
                        }
                    </MudSelect>
                    <MudSelect T="ChallengeCategory"
                    Label="Filter by Category"
                    Placeholder="Category"
                    Class="flex-grow-0"
                    MultiSelection="true"
                    @bind-SelectedValues="SelectedCategories">
                        @foreach (ChallengeCategory item in Enum.GetValues(typeof(ChallengeCategory)))
                        {
                            if(item != ChallengeCategory.Unknown)
                            {
                                <MudSelectItem Value="@item">@item.ToString()</MudSelectItem>
                            }
                        }
                    </MudSelect>
                </MudStack>
            </MudStack>
            <MudStack Spacing="4">
                @foreach (var challenge in PaginatedChallenges)
                {
                    <MudPaper Elevation="3" Outlined="false" Class="py-2 px-2 px-sm-5" Style="@(CompletedChallenges.Contains(challenge.Id) ? "border: 2px solid green;" : "")">
                        <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                            <MudStack Row Spacing="5">
                                <MudImage ObjectFit="ObjectFit.Contain" Width="60" Src="@($"img/belts/{challenge.Level}-belt.png")" />
                                <MudStack Spacing="1">
                                    <MudText Style="font-weight:bolder" Typo="Typo.subtitle1" Class="mud-primary-text">@challenge.Name</MudText>
                                    <MudText Typo="Typo.body2">@challenge.Description</MudText>
                                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                        @if(challenge.Category != ChallengeCategory.Unknown)
                                        {
                                            <MudText Style="font-weight:bolder" Typo="Typo.subtitle2">@challenge.Category.ToString()</MudText>
                                        }
                                        <MudText Style="font-weight:bolder" Typo="Typo.subtitle2">@challenge.Platform.ToString()</MudText>
                                        <MudImage ObjectFit="ObjectFit.Contain" Width="30" Src="img/experience.png" />
                                        <MudText Style="font-weight:bolder" Typo="Typo.subtitle2">@challenge.ExperiencePoints</MudText>
                                    </MudStack>
                                </MudStack>
                            </MudStack>
                            <MudStack Row Spacing="2" Breakpoint="Breakpoint.Xs">
                                <MudButton Size="@Size.Small"
                                Variant="@Variant.Filled"
                                Color="@Color.Warning"
                                OnClick="@(() => JS.InvokeVoidAsync("window.open", @ChallengeHelper.GetChallengeUrl(challenge.ExternalId, challenge.Platform), "_blank", "noopener,noreferrer"))"
                                StartIcon="fas fa-eye">
                                    View
                                </MudButton>
                                @if (!CompletedChallenges.Contains(challenge.Id))
                                {
                                    <MudButton Size="@Size.Small"
                                    Variant="@Variant.Filled"
                                    Color="@Color.Primary"
                                    Disabled="@(ProcessingChallenges.Contains(challenge.Id) || IsInCooldown(challenge.Id))"
                                    OnClick="@(() => Sync(challenge.Id, challenge.ExternalId, challenge.Platform))">
                                        @if (ProcessingChallenges.Contains(challenge.Id))
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                            <p>SYNCING...</p>
                                        }
                                        else if (IsInCooldown(challenge.Id))
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.Schedule" Size="Size.Small" Class="mr-2" />
                                            <p>WAIT...</p>
                                        }
                                        else
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.Cached" Size="Size.Small" Class="mr-2" />
                                            <p>SYNC</p>
                                        }
                                    </MudButton>
                                }
                            </MudStack>
                        </MudStack>
                    </MudPaper>
                }
            </MudStack>
            @if (Pages > 1) {
                <MudBreakpointProvider OnBreakpointChanged="BreakpointChanged">
                    <MudPagination Class="mt-3 justify-center"
                    Style="width: 100%;"
                    Count="Pages"
                    Selected="CurrentPage"
                    SelectedChanged="OnPageChanged"
                    BoundaryCount="_boundaryCount"
                    Size="_paginationSize" />
                </MudBreakpointProvider>
            }
        }
    }
</MudContainer>

@code {
    [Inject] private NavigationManager Navigation { get; set; }
    [Inject] private AuthenticationStateProvider AuthenticationState { get; set; }
    [Inject] private IChallengeService ChallengeService { get; set; }
    [Inject] private ChallengeManager ChallengeManager { get; set; }
    [Inject] private IUserService UserService { get; set; }

    [Inject] private IJSRuntime JS { get; set; }
    [Inject] private ISnackbar Snackbar { get; set; }

    private List<Challenge> ChallengesList = new();
    private DailyStreak UserStreak = new();
    private List<int> CompletedChallenges = new();
    private ApplicationUser User { get; set; }
    private List<Challenge> FilteredChallenges =>
        ChallengesList.Where(c =>
            (!_showCompleted || IsCompleted(c.Id)) &&
            (!_selectedLevels.Any() || _selectedLevels.Contains(c.Level)) &&
            (!_selectedCategories.Any() || _selectedCategories.Contains(c.Category))
        )
        .ToList();

    private List<Challenge> PaginatedChallenges => FilteredChallenges
        .Skip((CurrentPage - 1) * PagingConstants.ChallengesPageSize)
        .Take(PagingConstants.ChallengesPageSize)
        .ToList();

    private int Pages => (int)Math.Ceiling((double)TotalFilteredChallenges / PagingConstants.ChallengesPageSize);
    private int CurrentPage = 1;
    private int TotalFilteredChallenges => FilteredChallenges.Count;

    private IEnumerable<Level> _selectedLevels = new HashSet<Level>();
    private IEnumerable<Level> SelectedLevels
    {
        get => _selectedLevels;
        set
        {
            _selectedLevels = value;
            CurrentPage = 1;
        }
    }
    private IEnumerable<ChallengeCategory> _selectedCategories = new HashSet<ChallengeCategory>();
    private IEnumerable<ChallengeCategory> SelectedCategories
    {
        get => _selectedCategories;
        set
        {
            _selectedCategories = value;
            CurrentPage = 1;
        }
    }
    private bool _showCompleted = false;
    private bool ShowCompleted
    {
        get => _showCompleted;
        set
        {
            _showCompleted = value;
            CurrentPage = 1;
        }
    }

    private HashSet<int> ProcessingChallenges = new();
    private Dictionary<int, DateTime> ChallengeCooldowns = new();
    private const int CooldownSeconds = 3;
    private PeriodicTimer? CooldownTimer;
    private CancellationTokenSource CooldownCts = new();

    private bool IsLoading = true;
    private string UserId = string.Empty;
    private TimeSpan LoadTime = TimeSpan.Zero;
    private int _boundaryCount = 1;
    private Size _paginationSize = Size.Medium;

    protected override async Task OnInitializedAsync()
    {
        var startTime = DateTime.UtcNow;
        var authSate = await AuthenticationState.GetAuthenticationStateAsync();

        if (!authSate.User.Identity.IsAuthenticated)
        {
            Navigation.NavigateTo("Account/Login");
        }

        var claims = authSate.User;
        UserId = claims.FindFirstValue(ClaimTypes.NameIdentifier);
        User = await UserService.GetUserChallengeDetails(UserId);
        ChallengesList = await ChallengeService.GetChallenges(User.Level);
        CompletedChallenges = User.UserChallenges.Select(uc => uc.ChallengeId).ToList();
        UserStreak = await ChallengeService.GetStreakInfo(UserId);

        LoadTime = DateTime.UtcNow - startTime;

        IsLoading = false;
        CooldownTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = RunCooldownLoop();
    }

    private async Task RunCooldownLoop()
    {
        try
        {
            while (await CooldownTimer!.WaitForNextTickAsync(CooldownCts.Token))
            {
                if (ChallengeCooldowns.Count == 0)
                    continue;

                var now = DateTime.UtcNow;

                var expiredIds = ChallengeCooldowns
                    .Where(kvp => kvp.Value <= now)
                    .Select(kvp => kvp.Key)
                    .ToList();

                if (expiredIds.Count == 0)
                    continue;

                foreach (var id in expiredIds)
                    ChallengeCooldowns.Remove(id);

                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private bool IsCompleted(int id)
    {
        return CompletedChallenges.Contains(id);
    }

    private bool IsInCooldown(int challengeId)
    {
        return ChallengeCooldowns.TryGetValue(challengeId, out var until)
               && DateTime.UtcNow < until;
    }

    private void StartCooldown(int challengeId)
    {
        ChallengeCooldowns[challengeId] =
            DateTime.UtcNow.AddSeconds(CooldownSeconds);
    }

    private async Task Sync(int challengeId, string externalId, ChallengePlatform platform)
    {
        if (!ProcessingChallenges.Add(challengeId))
            return;

        if (IsInCooldown(challengeId))
        {
            ProcessingChallenges.Remove(challengeId);
            return;
        }

        var result = await ChallengeManager.Sync(new SyncChallengeRequest
        (
            new UserPlatformCredentials(User.CodeWarsUsername, User.LeetCodeUsername),
            challengeId,
            externalId,
            UserId
        ), platform);

        if (result.Status == ResponseStatus.Success)
        {
            Snackbar.Add("Sync Successful", Severity.Success);

            await ChallengeService.UpdateStreakInfo(UserId);
            UserStreak = await ChallengeService.GetStreakInfo(UserId);
            User = await UserService.GetUserChallengeDetails(UserId);
            CompletedChallenges = User.UserChallenges.Select(uc => uc.ChallengeId).ToList();
        }
        else
        {
            Snackbar.Add($"Error: {result.Message}", Severity.Error);
            StartCooldown(challengeId);
        }

        ProcessingChallenges.Remove(challengeId);
    }

    private void OnPageChanged(int page)
    {
        CurrentPage = page;
    }

    private void BreakpointChanged(Breakpoint breakpoint)
    {
        if (breakpoint < Breakpoint.Sm)
        {
            _paginationSize = Size.Small;
            _boundaryCount = 1;
        }
        else
        {
            _paginationSize = Size.Medium;
            _boundaryCount = 2;
        }
    }

    public void Dispose()
    {
        CooldownCts.Cancel();
        CooldownTimer?.Dispose();
    }
}